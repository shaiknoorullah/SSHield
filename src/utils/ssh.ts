import * as path from "path";
import { exec } from "child_process";
import { promisify } from "util";
import { SSHKey, KeyType, AgentStatus, AgentKey } from "../types";
import {
  DEFAULT_KEY_TYPE,
  DEFAULT_KEY_BITS,
  DEFAULT_KDF_ROUNDS,
  SSH_KEY_PERMISSIONS,
  SSH_PUB_KEY_PERMISSIONS,
} from "../constants";
import { log } from "./ui";
import { runCommand, writeFile, readFile, fileExists } from "./filesystem";
import { NodeSSH } from "node-ssh";
import * as crypto from "crypto";
import { format } from "date-fns";

const execAsync = promisify(exec);

/**
 * Generate a new SSH key pair with secure parameters
 */
export const generateKey = async (
  keyPath: string,
  options: {
    type?: KeyType;
    bits?: number;
    kdfRounds?: number;
    passphrase?: string;
    comment?: string;
  } = {}
): Promise<{ privateKey: string; publicKey: string }> => {
  const {
    type = DEFAULT_KEY_TYPE,
    bits = DEFAULT_KEY_BITS,
    kdfRounds = DEFAULT_KDF_ROUNDS,
    passphrase = "",
    comment = `generated by ssh-manager on ${new Date().toISOString()}`,
  } = options;

  // Build the ssh-keygen command
  let command = `ssh-keygen -t ${type}`;

  // Add key-specific options
  if (type === "rsa") {
    command += ` -b ${bits}`;
  }

  // Add KDF rounds for stronger passphrase protection
  command += ` -a ${kdfRounds}`;

  // Add output file and other options
  command += ` -f "${keyPath}" -C "${comment}"`;

  // Use a temporary file for the passphrase to avoid it showing in process list
  const passphraseFile = path.join(path.dirname(keyPath), ".passphrase-temp");
  await writeFile(passphraseFile, passphrase);

  try {
    // Use passphrase file
    command += ` -N "$(cat "${passphraseFile}")"`;

    // Execute the command
    await runCommand(command);

    // Read the generated files
    const privateKey = await readFile(keyPath);
    const publicKey = await readFile(`${keyPath}.pub`);

    // Set correct permissions
    await Promise.all([
      runCommand(`chmod ${SSH_KEY_PERMISSIONS.toString(8)} "${keyPath}"`),
      runCommand(
        `chmod ${SSH_PUB_KEY_PERMISSIONS.toString(8)} "${keyPath}.pub"`
      ),
    ]);

    return { privateKey, publicKey };
  } catch (error: any) {
    log.error(`Failed to generate SSH key: ${error.message}`);
    throw error;
  } finally {
    // Cleanup the passphrase file
    try {
      await runCommand(`rm -f "${passphraseFile}"`);
    } catch (error: any) {
      log.warn(`Failed to remove passphrase file: ${error.message}`);
    }
  }
};

/**
 * Get the fingerprint of an SSH key
 */
export const getKeyFingerprint = async (keyPath: string): Promise<string> => {
  try {
    // Use ssh-keygen to get the fingerprint in MD5 format
    const output = await runCommand(`ssh-keygen -l -E md5 -f "${keyPath}"`);
    // Extract the fingerprint part (second field)
    const match = output.match(/MD5:([a-f0-9:]+)/i);
    return match ? match[1] : "";
  } catch (error: any) {
    log.error(`Failed to get key fingerprint: ${error.message}`);
    throw error;
  }
};

/**
 * Start the SSH agent if not already running
 */
export const startAgent = async (): Promise<{
  agentPid: string;
  sshAuthSock: string;
}> => {
  try {
    // Start the SSH agent and parse its output
    const output = await runCommand("ssh-agent -s");

    // Extract SSH_AUTH_SOCK and SSH_AGENT_PID
    const sshAuthSockMatch = output.match(/SSH_AUTH_SOCK=([^;]+)/);
    const sshAgentPidMatch = output.match(/SSH_AGENT_PID=([^;]+)/);

    if (!sshAuthSockMatch || !sshAgentPidMatch) {
      throw new Error("Failed to parse ssh-agent output");
    }

    const sshAuthSock = sshAuthSockMatch[1];
    const agentPid = sshAgentPidMatch[1];

    // Set environment variables for the current process
    process.env.SSH_AUTH_SOCK = sshAuthSock;
    process.env.SSH_AGENT_PID = agentPid;

    return { agentPid, sshAuthSock };
  } catch (error: any) {
    log.error(`Failed to start SSH agent: ${error.message}`);
    throw error;
  }
};

/**
 * Stop the SSH agent
 */
export const stopAgent = async (): Promise<void> => {
  try {
    await runCommand("ssh-agent -k");
    delete process.env.SSH_AUTH_SOCK;
    delete process.env.SSH_AGENT_PID;
  } catch (error: any) {
    log.error(`Failed to stop SSH agent: ${error.message}`);
    throw error;
  }
};

/**
 * Get the status of the SSH agent
 */
export const getAgentStatus = async (): Promise<AgentStatus> => {
  // Check if the SSH agent is running
  if (!process.env.SSH_AUTH_SOCK || !process.env.SSH_AGENT_PID) {
    return { running: false };
  }

  try {
    // Check if the agent has any keys
    const output = await runCommand("ssh-add -l");

    // Parse output to get keys
    const keys: AgentKey[] = [];
    if (!output.includes("The agent has no identities")) {
      const keyLines = output.split("\n");

      for (const line of keyLines) {
        if (!line.trim()) continue;

        // Parse each line (format: bits type fingerprint comment)
        const parts = line.split(" ");
        if (parts.length >= 3) {
          const type = parts[1];
          const fingerprint = parts[2];
          const comment = parts.slice(3).join(" ");

          keys.push({
            type,
            fingerprint,
            comment,
            added: new Date().toISOString(),
          });
        }
      }
    }

    return {
      running: true,
      pid: parseInt(process.env.SSH_AGENT_PID, 10),
      socket: process.env.SSH_AUTH_SOCK,
      keys,
    };
  } catch (error: any) {
    // If ssh-add fails, the agent may not be running correctly
    return { running: false };
  }
};

/**
 * Add a key to the SSH agent
 */
export const addKeyToAgent = async (
  keyPath: string,
  options: {
    lifetime?: number;
    passphrase?: string;
  } = {}
): Promise<void> => {
  const { lifetime } = options;

  try {
    let command = "ssh-add";

    // Add lifetime option if specified
    if (lifetime) {
      command += ` -t ${lifetime}`;
    }

    command += ` "${keyPath}"`;

    // Execute the command
    await runCommand(command);
  } catch (error: any) {
    log.error(`Failed to add key to agent: ${error.message}`);
    throw error;
  }
};

/**
 * Remove a key from the SSH agent
 */
export const removeKeyFromAgent = async (keyPath: string): Promise<void> => {
  try {
    await runCommand(`ssh-add -d "${keyPath}"`);
  } catch (error: any) {
    log.error(`Failed to remove key from agent: ${error.message}`);
    throw error;
  }
};

/**
 * Remove all keys from the SSH agent
 */
export const removeAllKeysFromAgent = async (): Promise<void> => {
  try {
    await runCommand("ssh-add -D");
  } catch (error: any) {
    log.error(`Failed to remove all keys from agent: ${error.message}`);
    throw error;
  }
};

/**
 * Connect to a server using SSH
 */
export const connectToServer = async (
  hostname: string,
  options: {
    username: string;
    port?: number;
    keyPath?: string;
    passphrase?: string;
    command?: string;
  }
): Promise<NodeSSH> => {
  const { username, port = 22, keyPath, passphrase, command } = options;

  try {
    const ssh = new NodeSSH();

    // Connect to the server
    await ssh.connect({
      host: hostname,
      port,
      username,
      privateKey: keyPath,
      passphrase,
    });

    // Execute command if provided
    if (command) {
      const result = await ssh.execCommand(command);
      log.info(`Command execution result: ${result.stdout}`);
      if (result.stderr) {
        log.warn(`Command stderr: ${result.stderr}`);
      }
    }

    return ssh;
  } catch (error: any) {
    log.error(`Failed to connect to server ${hostname}: ${error.message}`);
    throw error;
  }
};

/**
 * Test SSH connection
 */
export const testConnection = async (
  hostname: string,
  options: {
    username: string;
    port?: number;
    keyPath?: string;
    passphrase?: string;
  }
): Promise<boolean> => {
  try {
    const ssh = await connectToServer(hostname, {
      ...options,
      command: 'echo "Connection successful"',
    });
    ssh.dispose();
    return true;
  } catch (error: any) {
    log.error(`Connection test failed: ${error.message}`);
    return false;
  }
};

/**
 * Generate a key name based on purpose and timestamp
 */
export const generateKeyName = (
  purpose: string,
  timestamp = new Date()
): string => {
  const formattedDate = format(timestamp, "yyyyMMdd-HHmmss");
  const sanitizedPurpose = purpose.replace(/[^a-zA-Z0-9_-]/g, "_");
  return `id_${DEFAULT_KEY_TYPE}_${sanitizedPurpose}_${formattedDate}`;
};

/**
 * Parse an SSH public key
 */
export const parsePublicKey = (
  publicKeyContent: string
): { type: string; key: string; comment?: string } => {
  const parts = publicKeyContent.trim().split(" ");

  if (parts.length < 2) {
    throw new Error("Invalid public key format");
  }

  const type = parts[0];
  const key = parts[1];
  const comment = parts.slice(2).join(" ") || undefined;

  return { type, key, comment };
};

/**
 * Format an SSH key entry for .ssh/config
 */
export const formatSshConfigEntry = (
  host: string,
  config: {
    hostname: string;
    user: string;
    port?: number;
    identityFile?: string;
    options?: Record<string, string | number | boolean>;
  }
): string => {
  const { hostname, user, port, identityFile, options = {} } = config;

  let entry = `Host ${host}\n`;
  entry += `    HostName ${hostname}\n`;
  entry += `    User ${user}\n`;

  if (port) {
    entry += `    Port ${port}\n`;
  }

  if (identityFile) {
    entry += `    IdentityFile ${identityFile}\n`;
  }

  // Add all other options
  for (const [key, value] of Object.entries(options)) {
    // Skip entries that we've already handled
    if (["HostName", "User", "Port", "IdentityFile"].includes(key)) {
      continue;
    }

    // Format the value based on its type
    let formattedValue: string;

    if (typeof value === "boolean") {
      formattedValue = value ? "yes" : "no";
    } else {
      formattedValue = String(value);
    }

    entry += `    ${key} ${formattedValue}\n`;
  }

  return entry;
};

/**
 * Update SSH config file with new entries
 */
export const updateSshConfig = async (
  configEntries: string[]
): Promise<void> => {
  try {
    // Read existing config
    const configPath = path.join(process.env.HOME || "", ".ssh", "config");
    let configContent = "";

    if (await fileExists(configPath)) {
      configContent = await readFile(configPath);
    }

    // Add new entries
    configContent += "\n\n# Added by ssh-manager\n";
    configContent += configEntries.join("\n\n");

    // Write updated config
    await writeFile(configPath, configContent, SSH_KEY_PERMISSIONS);
  } catch (error: any) {
    log.error(`Failed to update SSH config: ${error.message}`);
    throw error;
  }
};

/**
 * Generate a random port number for tunneling
 */
export const generateRandomPort = (): number => {
  // Generate a random port number between 10000 and 65535
  return Math.floor(Math.random() * 55535) + 10000;
};

/**
 * Create an SSH tunnel
 */
export const createSshTunnel = async (options: {
  localPort: number;
  remoteHost: string;
  remotePort: number;
  sshHost: string;
  sshPort?: number;
  sshUser: string;
  keyPath?: string;
}): Promise<{ process: any; localPort: number }> => {
  const {
    localPort,
    remoteHost,
    remotePort,
    sshHost,
    sshPort = 22,
    sshUser,
    keyPath,
  } = options;

  try {
    // Build SSH command for tunneling
    let command = `ssh -N -L ${localPort}:${remoteHost}:${remotePort}`;

    if (sshPort !== 22) {
      command += ` -p ${sshPort}`;
    }

    if (keyPath) {
      command += ` -i "${keyPath}"`;
    }

    command += ` ${sshUser}@${sshHost}`;

    // Start the SSH tunnel as a background process
    const child = exec(command);

    // Wait a bit to ensure the tunnel is established
    await new Promise((resolve) => setTimeout(resolve, 1000));

    return { process: child, localPort };
  } catch (error: any) {
    log.error(`Failed to create SSH tunnel: ${error.message}`);
    throw error;
  }
};

/**
 * Close an SSH tunnel
 */
export const closeSshTunnel = (process: any): void => {
  if (process) {
    process.kill();
  }
};
