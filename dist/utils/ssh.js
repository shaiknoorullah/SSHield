"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.closeSshTunnel = exports.createSshTunnel = exports.generateRandomPort = exports.updateSshConfig = exports.formatSshConfigEntry = exports.parsePublicKey = exports.generateKeyName = exports.testConnection = exports.connectToServer = exports.removeAllKeysFromAgent = exports.removeKeyFromAgent = exports.addKeyToAgent = exports.getAgentStatus = exports.stopAgent = exports.startAgent = exports.getKeyFingerprint = exports.generateKey = void 0;
const path = __importStar(require("path"));
const child_process_1 = require("child_process");
const util_1 = require("util");
const constants_1 = require("../constants");
const ui_1 = require("./ui");
const filesystem_1 = require("./filesystem");
const node_ssh_1 = require("node-ssh");
const date_fns_1 = require("date-fns");
const execAsync = (0, util_1.promisify)(child_process_1.exec);
/**
 * Generate a new SSH key pair with secure parameters
 */
const generateKey = async (keyPath, options = {}) => {
    const { type = constants_1.DEFAULT_KEY_TYPE, bits = constants_1.DEFAULT_KEY_BITS, kdfRounds = constants_1.DEFAULT_KDF_ROUNDS, passphrase = "", comment = `generated by ssh-manager on ${new Date().toISOString()}`, } = options;
    // Build the ssh-keygen command
    let command = `ssh-keygen -t ${type}`;
    // Add key-specific options
    if (type === "rsa") {
        command += ` -b ${bits}`;
    }
    // Add KDF rounds for stronger passphrase protection
    command += ` -a ${kdfRounds}`;
    // Add output file and other options
    command += ` -f "${keyPath}" -C "${comment}"`;
    // Use a temporary file for the passphrase to avoid it showing in process list
    const passphraseFile = path.join(path.dirname(keyPath), ".passphrase-temp");
    await (0, filesystem_1.writeFile)(passphraseFile, passphrase);
    try {
        // Use passphrase file
        command += ` -N "$(cat "${passphraseFile}")"`;
        // Execute the command
        await (0, filesystem_1.runCommand)(command);
        // Read the generated files
        const privateKey = await (0, filesystem_1.readFile)(keyPath);
        const publicKey = await (0, filesystem_1.readFile)(`${keyPath}.pub`);
        // Set correct permissions
        await Promise.all([
            (0, filesystem_1.runCommand)(`chmod ${constants_1.SSH_KEY_PERMISSIONS.toString(8)} "${keyPath}"`),
            (0, filesystem_1.runCommand)(`chmod ${constants_1.SSH_PUB_KEY_PERMISSIONS.toString(8)} "${keyPath}.pub"`),
        ]);
        return { privateKey, publicKey };
    }
    catch (error) {
        ui_1.log.error(`Failed to generate SSH key: ${error.message}`);
        throw error;
    }
    finally {
        // Cleanup the passphrase file
        try {
            await (0, filesystem_1.runCommand)(`rm -f "${passphraseFile}"`);
        }
        catch (error) {
            ui_1.log.warn(`Failed to remove passphrase file: ${error.message}`);
        }
    }
};
exports.generateKey = generateKey;
/**
 * Get the fingerprint of an SSH key
 */
const getKeyFingerprint = async (keyPath) => {
    try {
        // Use ssh-keygen to get the fingerprint in MD5 format
        const output = await (0, filesystem_1.runCommand)(`ssh-keygen -l -E md5 -f "${keyPath}"`);
        // Extract the fingerprint part (second field)
        const match = output.match(/MD5:([a-f0-9:]+)/i);
        return match ? match[1] : "";
    }
    catch (error) {
        ui_1.log.error(`Failed to get key fingerprint: ${error.message}`);
        throw error;
    }
};
exports.getKeyFingerprint = getKeyFingerprint;
/**
 * Start the SSH agent if not already running
 */
const startAgent = async () => {
    try {
        // Start the SSH agent and parse its output
        const output = await (0, filesystem_1.runCommand)("ssh-agent -s");
        // Extract SSH_AUTH_SOCK and SSH_AGENT_PID
        const sshAuthSockMatch = output.match(/SSH_AUTH_SOCK=([^;]+)/);
        const sshAgentPidMatch = output.match(/SSH_AGENT_PID=([^;]+)/);
        if (!sshAuthSockMatch || !sshAgentPidMatch) {
            throw new Error("Failed to parse ssh-agent output");
        }
        const sshAuthSock = sshAuthSockMatch[1];
        const agentPid = sshAgentPidMatch[1];
        // Set environment variables for the current process
        process.env.SSH_AUTH_SOCK = sshAuthSock;
        process.env.SSH_AGENT_PID = agentPid;
        return { agentPid, sshAuthSock };
    }
    catch (error) {
        ui_1.log.error(`Failed to start SSH agent: ${error.message}`);
        throw error;
    }
};
exports.startAgent = startAgent;
/**
 * Stop the SSH agent
 */
const stopAgent = async () => {
    try {
        await (0, filesystem_1.runCommand)("ssh-agent -k");
        delete process.env.SSH_AUTH_SOCK;
        delete process.env.SSH_AGENT_PID;
    }
    catch (error) {
        ui_1.log.error(`Failed to stop SSH agent: ${error.message}`);
        throw error;
    }
};
exports.stopAgent = stopAgent;
/**
 * Get the status of the SSH agent
 */
const getAgentStatus = async () => {
    // Check if the SSH agent is running
    if (!process.env.SSH_AUTH_SOCK || !process.env.SSH_AGENT_PID) {
        return { running: false };
    }
    try {
        // Check if the agent has any keys
        const output = await (0, filesystem_1.runCommand)("ssh-add -l");
        // Parse output to get keys
        const keys = [];
        if (!output.includes("The agent has no identities")) {
            const keyLines = output.split("\n");
            for (const line of keyLines) {
                if (!line.trim())
                    continue;
                // Parse each line (format: bits type fingerprint comment)
                const parts = line.split(" ");
                if (parts.length >= 3) {
                    const type = parts[1];
                    const fingerprint = parts[2];
                    const comment = parts.slice(3).join(" ");
                    keys.push({
                        type,
                        fingerprint,
                        comment,
                        added: new Date().toISOString(),
                    });
                }
            }
        }
        return {
            running: true,
            pid: parseInt(process.env.SSH_AGENT_PID, 10),
            socket: process.env.SSH_AUTH_SOCK,
            keys,
        };
    }
    catch (error) {
        // If ssh-add fails, the agent may not be running correctly
        return { running: false };
    }
};
exports.getAgentStatus = getAgentStatus;
/**
 * Add a key to the SSH agent
 */
const addKeyToAgent = async (keyPath, options = {}) => {
    const { lifetime } = options;
    try {
        let command = "ssh-add";
        // Add lifetime option if specified
        if (lifetime) {
            command += ` -t ${lifetime}`;
        }
        command += ` "${keyPath}"`;
        // Execute the command
        await (0, filesystem_1.runCommand)(command);
    }
    catch (error) {
        ui_1.log.error(`Failed to add key to agent: ${error.message}`);
        throw error;
    }
};
exports.addKeyToAgent = addKeyToAgent;
/**
 * Remove a key from the SSH agent
 */
const removeKeyFromAgent = async (keyPath) => {
    try {
        await (0, filesystem_1.runCommand)(`ssh-add -d "${keyPath}"`);
    }
    catch (error) {
        ui_1.log.error(`Failed to remove key from agent: ${error.message}`);
        throw error;
    }
};
exports.removeKeyFromAgent = removeKeyFromAgent;
/**
 * Remove all keys from the SSH agent
 */
const removeAllKeysFromAgent = async () => {
    try {
        await (0, filesystem_1.runCommand)("ssh-add -D");
    }
    catch (error) {
        ui_1.log.error(`Failed to remove all keys from agent: ${error.message}`);
        throw error;
    }
};
exports.removeAllKeysFromAgent = removeAllKeysFromAgent;
/**
 * Connect to a server using SSH
 */
const connectToServer = async (hostname, options) => {
    const { username, port = 22, keyPath, passphrase, command } = options;
    try {
        const ssh = new node_ssh_1.NodeSSH();
        // Connect to the server
        await ssh.connect({
            host: hostname,
            port,
            username,
            privateKey: keyPath,
            passphrase,
        });
        // Execute command if provided
        if (command) {
            const result = await ssh.execCommand(command);
            ui_1.log.info(`Command execution result: ${result.stdout}`);
            if (result.stderr) {
                ui_1.log.warn(`Command stderr: ${result.stderr}`);
            }
        }
        return ssh;
    }
    catch (error) {
        ui_1.log.error(`Failed to connect to server ${hostname}: ${error.message}`);
        throw error;
    }
};
exports.connectToServer = connectToServer;
/**
 * Test SSH connection
 */
const testConnection = async (hostname, options) => {
    try {
        const ssh = await (0, exports.connectToServer)(hostname, {
            ...options,
            command: 'echo "Connection successful"',
        });
        ssh.dispose();
        return true;
    }
    catch (error) {
        ui_1.log.error(`Connection test failed: ${error.message}`);
        return false;
    }
};
exports.testConnection = testConnection;
/**
 * Generate a key name based on purpose and timestamp
 */
const generateKeyName = (purpose, timestamp = new Date()) => {
    const formattedDate = (0, date_fns_1.format)(timestamp, "yyyyMMdd-HHmmss");
    const sanitizedPurpose = purpose.replace(/[^a-zA-Z0-9_-]/g, "_");
    return `id_${constants_1.DEFAULT_KEY_TYPE}_${sanitizedPurpose}_${formattedDate}`;
};
exports.generateKeyName = generateKeyName;
/**
 * Parse an SSH public key
 */
const parsePublicKey = (publicKeyContent) => {
    const parts = publicKeyContent.trim().split(" ");
    if (parts.length < 2) {
        throw new Error("Invalid public key format");
    }
    const type = parts[0];
    const key = parts[1];
    const comment = parts.slice(2).join(" ") || undefined;
    return { type, key, comment };
};
exports.parsePublicKey = parsePublicKey;
/**
 * Format an SSH key entry for .ssh/config
 */
const formatSshConfigEntry = (host, config) => {
    const { hostname, user, port, identityFile, options = {} } = config;
    let entry = `Host ${host}\n`;
    entry += `    HostName ${hostname}\n`;
    entry += `    User ${user}\n`;
    if (port) {
        entry += `    Port ${port}\n`;
    }
    if (identityFile) {
        entry += `    IdentityFile ${identityFile}\n`;
    }
    // Add all other options
    for (const [key, value] of Object.entries(options)) {
        // Skip entries that we've already handled
        if (["HostName", "User", "Port", "IdentityFile"].includes(key)) {
            continue;
        }
        // Format the value based on its type
        let formattedValue;
        if (typeof value === "boolean") {
            formattedValue = value ? "yes" : "no";
        }
        else {
            formattedValue = String(value);
        }
        entry += `    ${key} ${formattedValue}\n`;
    }
    return entry;
};
exports.formatSshConfigEntry = formatSshConfigEntry;
/**
 * Update SSH config file with new entries
 */
const updateSshConfig = async (configEntries) => {
    try {
        // Read existing config
        const configPath = path.join(process.env.HOME || "", ".ssh", "config");
        let configContent = "";
        if (await (0, filesystem_1.fileExists)(configPath)) {
            configContent = await (0, filesystem_1.readFile)(configPath);
        }
        // Add new entries
        configContent += "\n\n# Added by ssh-manager\n";
        configContent += configEntries.join("\n\n");
        // Write updated config
        await (0, filesystem_1.writeFile)(configPath, configContent, constants_1.SSH_KEY_PERMISSIONS);
    }
    catch (error) {
        ui_1.log.error(`Failed to update SSH config: ${error.message}`);
        throw error;
    }
};
exports.updateSshConfig = updateSshConfig;
/**
 * Generate a random port number for tunneling
 */
const generateRandomPort = () => {
    // Generate a random port number between 10000 and 65535
    return Math.floor(Math.random() * 55535) + 10000;
};
exports.generateRandomPort = generateRandomPort;
/**
 * Create an SSH tunnel
 */
const createSshTunnel = async (options) => {
    const { localPort, remoteHost, remotePort, sshHost, sshPort = 22, sshUser, keyPath, } = options;
    try {
        // Build SSH command for tunneling
        let command = `ssh -N -L ${localPort}:${remoteHost}:${remotePort}`;
        if (sshPort !== 22) {
            command += ` -p ${sshPort}`;
        }
        if (keyPath) {
            command += ` -i "${keyPath}"`;
        }
        command += ` ${sshUser}@${sshHost}`;
        // Start the SSH tunnel as a background process
        const child = (0, child_process_1.exec)(command);
        // Wait a bit to ensure the tunnel is established
        await new Promise((resolve) => setTimeout(resolve, 1000));
        return { process: child, localPort };
    }
    catch (error) {
        ui_1.log.error(`Failed to create SSH tunnel: ${error.message}`);
        throw error;
    }
};
exports.createSshTunnel = createSshTunnel;
/**
 * Close an SSH tunnel
 */
const closeSshTunnel = (process) => {
    if (process) {
        process.kill();
    }
};
exports.closeSshTunnel = closeSshTunnel;
//# sourceMappingURL=ssh.js.map